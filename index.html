<!doctype html>
<html lang="ru">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Язык программирования Rust</title>
    <link href="css/main.css" rel="stylesheet"/>
  </head>
  <body class="impress-not-supported">
    <div class="fallback-message">
      <p>Ваш обозреватель <b>не поддерживает возможности, необходимые для корректной работы</b> impress.js, поэтому презентация будет показана в упрощенном виде.</p>
    </div>
    <div id="impress">
      <div id="intro-gc" class="step slide" data-x="-1000" data-y="-1500">
        <h3>Жалко ресурсов на сборку мусора, но и не хочется заниматься ручным управлением памятью?</h3>        
      </div>
      <div id="intro-tr" class="step slide" data-x="0" data-y="-1500">
        <h3>Хочется потокобезопасности без накладных расходов во время выполнения?</h3>
      </div>
      <div id="rust-pl" class="step" data-x="-500" data-y="-500" data-scale="2">
        <p>Тогда вам будет интересно узнать про язык программирования <b>Rust</b></p>     
      </div>
      <div id="rust-info" class="step" data-x="1500" data-y="-500" data-scale="2">
        <p>Разрабатывается <b>Mozilla Foundation</b> при поддержке комьюнити</p>
        <span><img src="assets/mozilla-logo.png"/><img src="assets/rustacean-logo.png"/></span>
        <p>Разработка ведётся на <a href="https://github.com/rust-lang/rust">GitHub</a></p>
      </div>
      <div id="about" class="step slide" data-x="3500" data-y="-500" data-rotate="90" data-scale="3">
        <h3>Что же такое <b>Rust</b>?</h3>
        <p>Это системный язык программирования, который предотвращает утечки памяти, обращение к освобождённым данным, ситуации гонок в многопоточных приложениях без накладных расходов во время выполнения.</p>
        <p>Кроме того стоит заметить, что абстракции в <b>Rust</b> также имеют нулевую стоимость за счёт статической диспетчеризации во время компиляции.</p>
      </div>
      <div id="compare-gc" class="step slide" data-x="3500" data-y="2000", data-rotate="180" data-scale="3">
        <h3>Работа с памятью</h3>
        <p>Безопасные языки вроде <b>Java</b>, <b>C#</b>, <b>Python</b>, <b>JavaScript</b> используют сборщики мусора. Для сборщиков мусора требуется некая среда исполнения с наличием в ней сборщика мусора, кроме того сборщик отнимает процессорное время у приложения.
        <p>Небезопасные языки вроде <b>C</b>/<b>C++</b> не создают дополнительных накладных расходов, однако весь менеджмент памятью остаётся полностью на разработчике, что зачастую выливается в увлекательные поиски трудноповторимого редкого бага.</p>
      </div>
      <div id="binging-1" class="step slide" data-x="1750" data-y="1525", data-rotate="90" data-scale="1">
        <h3>Связывание имён</h3>
        <p>Любая программа на <b>Rust</b> использует связывание имён. Они связывают значение с именем, для того чтобы воспользоваться им позже. Для связывания используется ключевое слово <b>let</b>:</p>
        <pre>
<span class="keyword">fn</span> main() {
    <span class="keyword">let</span> x = <span class="number">5</span>;
}</pre>
        <p>Далее будем считать, что все действия происходят внутри функции <b>main</b></p> 
      </div>
      <div id="binging-2" class="step slide" data-x="1750" data-y="2475", data-rotate="90" data-scale="1">
        <h3>Шаблоны связывания</h3>
        <p>В левой части выражения <b>let</b> располагается не просто имя переменной, а "шаблон". Связываение происходит попарно имя-значение:</p>
        <pre>
<span class="keyword">let</span> (x, y) = (<span class="number">5</span>, <span class="number">6</span>);

println!(<span class="string">"x = {}"</span>, x); <span class="comment">// x = 5</span>
println!(<span class="string">"y = {}"</span>, y); <span class="comment">// y = 6</span>
        </pre>   
      </div>
      <div id="binging-3" class="step slide" data-x="1750" data-y="3425", data-rotate="90" data-scale="1">
        <h3>Изменяемость</h3>
        <p>По умолчанию связывание неизменяемое:</p>
        <pre>
<span class="keyword">let</span> x = <span class="number">7</span>;
x = <span class="number">5</span>; <span class="comment">// Ошибка компиляции</span></pre>
        <p>Чтобы связывание было изменяемым, нужно использовать модификатор <b>mut</b> при связывании:</p>
        <pre>
<span class="keyword">let mut</span> x = <span class="number">7</span>;
x = <span class="number">5</span>;
println!(<span class="string">"x = {}"</span>, x); <span class="comment">// x = 5</span></pre>
      </div>
      <div id="binging-4" class="step slide" data-x="1750" data-y="4375", data-rotate="90" data-scale="1">
        <h3>Строгая типизация</h3>
        <p><b>Rust</b> является статически типизированным языком программирования, однако чаще всего указывать тип вручную не требуется, поскольку в <b>Rust</b> имеется вывод типов из контекста.</p>
        <p>Если всё же понадобилось указать тип вручную, то это можно сделать следующим образом:</p>
        <pre>
<span class="keyword">let</span> x: <span class="keyword">i32</span> = <span class="number">10</span>;
<span class="keyword">let</span> x = <span class="number">10i32</span>;</pre>
        <p>Второй способ применим только для литералов</p>
      </div>
        <div id="mutability-2" class="step slide" data-x="1000" data-y="1525", data-rotate="90" data-scale="1">
        <p>Связанные имена имеют область видимости — они ограничены блоком, в котором они были объявлены.</p>
        <p>Помимо прочего, связанные имена могут быть затенены. Это значит, что, если объявить связывание с именем, которое уже существует, то оно переопределит предыдущее.</p>
        <p>Затенение и изменяемое связывание могут казаться двумя сторонами одной монеты, но они являются двумя отдельными концепциями, которые не всегда взаимозаменяемы. Например, затенение позволяет связать имя с другим типом или изменить связь с изменяемой на неизменяемую.</p>
      </div>
      <div id="mutability-3" class="step slide" data-x="1000" data-y="2475", data-rotate="90" data-scale="1">  
        <p>У каждого связывания в <b>Rust</b> одновременно может быть лишь один владелец. Владелец может либо передать владение, либо одолжить изменяемо или константно другому объекту.</p>
        <p>Заимствование по своей сути является передачей ссылки. Важно, что в <b>Rust</b> одновременно может существовать либо одна мутабельная ссылка, либо сколько угодно константных.</p>
        <p>В <b>Rust</b> также различают копируемые и некопируемые типы. Принципиальное их отличие в том, что первые не имеют внутри себя изменяемую ссылку, а вторые имеют. При передаче владения копируемого типа создаётся копия данных и передаётся владение именно копией, но если тип некопируемый, то передаётся владение исходными данными, а старое связывание теряется.</p>
      </div>    
      <div id="mutability-4" class="step slide" data-x="1000" data-y="3425", data-rotate="90" data-scale="1">
        <h3>Что выведет следующий код?</h3>
        <pre> 
<span class="keyword">fn</span> take(<span class="keyword">mut</span> v: Vec&lt;i32&gt;) {
    v.pop();
    v.push(<span class="number">2</span>);
}

<span class="keyword">fn</span> main() {
    <span class="keyword">let mut</span> vec = Vec::&lt;i32&gt;::new();
    vec.push(<span class="number">1</span>);
    take(vec);
    println!(<span class="string">"{}"</span>, vec[<span class="number">0</span>]);
}
        </pre>
      </div>
      <div id="mutability-5" class="step" data-x="50" data-y="1525" data-z="500" data-rotate-y="90" data-rotate="90" data-scale="1">
        <h3>Он не скомпилируется</h3>
        <pre>
<span class="error">error</span>: <b>use of moved value: `vec`</b> [E0382]
       println!("{}", vec[0]);
                      <span class="error">^~~</span>
<span class="note">note</span>: <b>vec moved here because 
      it has type collections::vec::Vec&lt;i32&gt;, 
      which is non-copyable</b>
      take(vec);
           <span class="error">^~~</span>
<span class="error">error</span>: <b>aborting due to previous error</b>
        </pre>
      </div>
      <div id="mutability-6" class="step" data-x="50" data-y="3475" data-z="500" data-rotate="90" data-rotate-y="90" data-scale="1">
        <h3>Исправляем</h3>
        <pre> 
<span class="keyword">fn</span> take(v: <span class="keyword">&amp;mut</span> Vec&lt;i32&gt;) {
    v.pop();
    v.push(<span class="number">2</span>);
}

<span class="keyword">fn</span> main() {
    <span class="keyword">let mut</span> vec = Vec::&lt;i32&gt;::new();
    vec.push(<span class="number">1</span>);
    take(<span class="keyword">&amp;mut</span> vec);
    println!(<span class="string">"{}"</span>, vec[<span class="number">0</span>]);
}
        </pre>
      </div>
      <div class="step slide" scale="2" data-x="-2000" data-y="2000">
        <h3>Источники</h3>
        <p>Официальный сайт <a href="https://www.rust-lang.org/">www.rust-lang.org</a><p>
        <p>Книга <a href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a> и её перевод <a href="https://gitter.im/ruRust/general">RuRust</a> сообществом <a href="http://rurust.github.io/rust_book_ru/">Язык Программирования Rust</a></p>
        <h3>Code Rust - Be Awesome ;)</h3>
        <p>Powered by <a href="https://github.com/impress/impress.js">ImpressJS </a></p>    
      <div>
      <div id="view-all" class="step" data-x="0" data-y="0" data-scale="7"></div>
    </div>    
    <script src="js/impress.js"></script>
    <script>impress().init();</script>
  </body>
</html>